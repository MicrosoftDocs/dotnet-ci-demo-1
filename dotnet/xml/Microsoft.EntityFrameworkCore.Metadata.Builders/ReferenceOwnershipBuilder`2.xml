<Type Name="ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;" FullName="Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;">
  <TypeSignature Language="C#" Value="public class ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; : Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder where TEntity : class where TRelatedEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReferenceOwnershipBuilder`2&lt;class TEntity, class TRelatedEntity&gt; extends Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2" />
  <TypeSignature Language="VB.NET" Value="Public Class ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)&#xA;Inherits ReferenceOwnershipBuilder" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TRelatedEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TEntity">To be added.</typeparam>
    <typeparam name="TRelatedEntity">To be added.</typeparam>
    <summary>
      <para>
                    Provides a simple API for configuring a one-to-one ownership.
                </para>
    </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReferenceOwnershipBuilder (Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType relatedEntityType, Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType declaringEntityType, class Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType relatedEntityType, class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType,Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (declaringEntityType As EntityType, relatedEntityType As EntityType, builder As InternalRelationshipBuilder)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="declaringEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" />
        <Parameter Name="relatedEntityType" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.EntityType" />
        <Parameter Name="builder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder" />
      </Parameters>
      <Docs>
        <param name="declaringEntityType">To be added.</param>
        <param name="relatedEntityType">To be added.</param>
        <param name="builder">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReferenceOwnershipBuilder (Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder builder, Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder oldBuilder, bool inverted = false, bool foreignKeySet = false, bool principalKeySet = false, bool requiredSet = false);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder builder, class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder oldBuilder, bool inverted, bool foreignKeySet, bool principalKeySet, bool requiredSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder,Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (builder As InternalRelationshipBuilder, oldBuilder As ReferenceOwnershipBuilder, Optional inverted As Boolean = false, Optional foreignKeySet As Boolean = false, Optional principalKeySet As Boolean = false, Optional requiredSet As Boolean = false)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalRelationshipBuilder" />
        <Parameter Name="oldBuilder" Type="Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder" />
        <Parameter Name="inverted" Type="System.Boolean" />
        <Parameter Name="foreignKeySet" Type="System.Boolean" />
        <Parameter Name="principalKeySet" Type="System.Boolean" />
        <Parameter Name="requiredSet" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="builder">To be added.</param>
        <param name="oldBuilder">To be added.</param>
        <param name="inverted">To be added.</param>
        <param name="foreignKeySet">To be added.</param>
        <param name="principalKeySet">To be added.</param>
        <param name="requiredSet">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChangeTrackingStrategy">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasChangeTrackingStrategy (Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasChangeTrackingStrategy(valuetype Microsoft.EntityFrameworkCore.ChangeTrackingStrategy changeTrackingStrategy) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasChangeTrackingStrategy(Microsoft.EntityFrameworkCore.ChangeTrackingStrategy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeTrackingStrategy" Type="Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" />
      </Parameters>
      <Docs>
        <param name="changeTrackingStrategy"> The change tracking strategy to be used. </param>
        <summary>
                Configures the <see cref="T:Microsoft.EntityFrameworkCore.ChangeTrackingStrategy" /> to be used for this entity type.
                This strategy indicates how the context detects changes to properties for an instance of the entity type.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasEntityTypeAnnotation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasEntityTypeAnnotation (string annotation, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasEntityTypeAnnotation(string annotation, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasEntityTypeAnnotation(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasEntityTypeAnnotation (annotation As String, value As Object) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="annotation"> The key of the annotation to be added or updated. </param>
        <param name="value"> The value to be stored in the annotation. </param>
        <summary>
                Adds or updates an annotation on the entity type. If an annotation with the key specified in
                <paramref name="annotation" /> already exists its value will be updated.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasForeignKey (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,object&gt;&gt; foreignKeyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasForeignKey(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, object&gt;&gt; foreignKeyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasForeignKey(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasForeignKey (foreignKeyExpression As Expression(Of Func(Of TRelatedEntity, Object))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKeyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="foreignKeyExpression">
          <para>
                    A lambda expression representing the foreign key property(s) (<c>t =&gt; t.Id1</c>).
                </para>
          <para>
                    If the foreign key is made up of multiple properties then specify an anonymous type including the
                    properties (<c>t =&gt; new { t.Id1, t.Id2 }</c>). The order specified should match the order of
                    corresponding keys in <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.String[])" />.
                </para>
        </param>
        <summary>
          <para>
                    Configures the property(s) to use as the foreign key for this relationship.
                </para>
          <para>
                    If the specified property name(s) do not exist on the entity type then a new shadow state
                    property(s) will be added to serve as the foreign key. A shadow state property is one
                    that does not have a corresponding property in the entity class. The current value for the
                    property is stored in the <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker" /> rather than being stored in instances
                    of the entity class.
                </para>
          <para>
                    If <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.String[])" /> is not specified, then an attempt will be made to
                    match the data type and order of foreign key properties against the primary key of the principal
                    entity type. If they do not match, new shadow state properties that form a unique index will be
                    added to the principal entity type to serve as the reference key.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasForeignKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasForeignKey (params string[] foreignKeyPropertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasForeignKey(string[] foreignKeyPropertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasForeignKey(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasForeignKey (ParamArray foreignKeyPropertyNames As String()) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foreignKeyPropertyNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="foreignKeyPropertyNames">
                The name(s) of the foreign key property(s).
            </param>
        <summary>
          <para>
                    Configures the property(s) to use as the foreign key for this relationship.
                </para>
          <para>
                    If the specified property name(s) do not exist on the entity type then a new shadow state
                    property(s) will be added to serve as the foreign key. A shadow state property is one
                    that does not have a corresponding property in the entity class. The current value for the
                    property is stored in the <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker" /> rather than being stored in instances
                    of the entity class.
                </para>
          <para>
                    If <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.String[])" /> is not specified, then an attempt will be made to
                    match the data type and order of foreign key properties against the primary key of the principal
                    entity type. If they do not match, new shadow state properties that form a unique index will be
                    added to the principal entity type to serve as the reference key.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasForeignKeyAnnotation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasForeignKeyAnnotation (string annotation, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasForeignKeyAnnotation(string annotation, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasForeignKeyAnnotation(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasForeignKeyAnnotation (annotation As String, value As Object) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="annotation"> The key of the annotation to be added or updated. </param>
        <param name="value"> The value to be stored in the annotation. </param>
        <summary>
                Adds or updates an annotation on the foreign key. If an annotation with the key specified in
                <paramref name="annotation" /> already exists its value will be updated.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasIndex">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.IndexBuilder HasIndex (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,object&gt;&gt; indexExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.IndexBuilder HasIndex(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, object&gt;&gt; indexExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasIndex(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasIndex (indexExpression As Expression(Of Func(Of TRelatedEntity, Object))) As IndexBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.IndexBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="indexExpression">
          <para>
                    A lambda expression representing the property(s) to be included in the index
                    (<c>blog =&gt; blog.Url</c>).
                </para>
          <para>
                    If the index is made up of multiple properties then specify an anonymous type including the
                    properties (<c>post =&gt; new { post.Title, post.BlogId }</c>).
                </para>
        </param>
        <summary>
                Configures an index on the specified properties. If there is an existing index on the given
                set of properties, then the existing index will be returned for configuration.
            </summary>
        <returns> An object that can be used to configure the index. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasMany&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt; HasMany&lt;TNewRelatedEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,System.Collections.Generic.IEnumerable&lt;TNewRelatedEntity&gt;&gt;&gt; navigationExpression = null) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt; HasMany&lt;class TNewRelatedEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, class System.Collections.Generic.IEnumerable`1&lt;!!TNewRelatedEntity&gt;&gt;&gt; navigationExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasMany``1(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{``0}}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasMany(Of TNewRelatedEntity As Class) (Optional navigationExpression As Expression(Of Func(Of TRelatedEntity, IEnumerable(Of TNewRelatedEntity))) = null) As CollectionNavigationBuilder(Of TRelatedEntity, TNewRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Collections.Generic.IEnumerable&lt;TNewRelatedEntity&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the collection navigation property on this entity type that represents
                the relationship (<c>blog =&gt; blog.Posts</c>). If no property is specified, the relationship will be
                configured without a navigation property on this end.
            </param>
        <summary>
          <para>
                    Configures a relationship where this entity type has a collection that contains
                    instances of the other type in the relationship.
                </para>
          <para>
                    After calling this method, you should chain a call to
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.CollectionNavigationBuilder`2.WithOne(System.Linq.Expressions.Expression{System.Func{`1,`0}})" />
                    to fully configure the relationship. Calling just this method without the chained call will not
                    produce a valid relationship.
                </para>
        </summary>
        <returns> An object that can be used to configure the relationship. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt; HasOne&lt;TNewRelatedEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; navigationExpression = null) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt; HasOne&lt;class TNewRelatedEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; navigationExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasOne``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasOne(Of TNewRelatedEntity As Class) (Optional navigationExpression As Expression(Of Func(Of TRelatedEntity, TNewRelatedEntity)) = null) As ReferenceNavigationBuilder(Of TRelatedEntity, TNewRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the reference navigation property on this entity type that represents
                the relationship (<c>post =&gt; post.Blog</c>). If no property is specified, the relationship will be
                configured without a navigation property on this end.
            </param>
        <summary>
          <para>
                    Configures a relationship where this entity type has a reference that points
                    to a single instance of the other type in the relationship.
                </para>
          <para>
                    After calling this method, you should chain a call to
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2.WithMany(System.Linq.Expressions.Expression{System.Func{`1,System.Collections.Generic.IEnumerable{`0}}})" />
                    or
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceNavigationBuilder`2.WithOne(System.Linq.Expressions.Expression{System.Func{`1,`0}})" />
                    to fully configure the relationship. Calling just this method without the chained call will not
                    produce a valid relationship.
                </para>
        </summary>
        <returns> An object that can be used to configure the relationship. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrincipalKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasPrincipalKey (System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; keyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasPrincipalKey(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TEntity, object&gt;&gt; keyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasPrincipalKey (keyExpression As Expression(Of Func(Of TEntity, Object))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="keyExpression">
          <para>
                    A lambda expression representing the reference key property(s) (<c>t =&gt; t.Id</c>).
                </para>
          <para>
                    If the principal key is made up of multiple properties then specify an anonymous type including
                    the properties (<c>t =&gt; new { t.Id1, t.Id2 }</c>).
                </para>
        </param>
        <summary>
                Configures the unique property(s) that this relationship targets. Typically you would only call this
                method if you want to use a property(s) other than the primary key as the principal property(s). If
                the specified property(s) is not already a unique constraint (or the primary key) then a new unique
                constraint will be introduced.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>
          <para>
                    If multiple principal key properties are specified, the order of principal key properties should
                    match the order that the primary key or unique constraint properties were configured on the principal
                    entity type.
                </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrincipalKey">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; HasPrincipalKey (params string[] keyPropertyNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; HasPrincipalKey(string[] keyPropertyNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.HasPrincipalKey(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasPrincipalKey (ParamArray keyPropertyNames As String()) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyPropertyNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="keyPropertyNames"> The name(s) of the reference key property(s). </param>
        <summary>
                Configures the unique property(s) that this relationship targets. Typically you would only call this
                method if you want to use a property(s) other than the primary key as the principal property(s). If
                the specified property(s) is not already a unique constraint (or the primary key) then a new unique
                constraint will be introduced.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>
          <para>
                    If multiple principal key properties are specified, the order of principal key properties should
                    match the order that the primary key or unique constraint properties were configured on the principal
                    entity type.
                </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; Ignore (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,object&gt;&gt; propertyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; Ignore(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, object&gt;&gt; propertyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.Ignore(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Ignore (propertyExpression As Expression(Of Func(Of TRelatedEntity, Object))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyExpression">
                A lambda expression representing the property to be ignored
                (<c>blog =&gt; blog.Url</c>).
            </param>
        <summary>
                Excludes the given property from the entity type. This method is typically used to remove properties
                from the entity type that were added by convention.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; Ignore (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; Ignore(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Ignore (propertyName As String) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName"> The name of then property to be removed from the entity type. </param>
        <summary>
                Excludes the given property from the entity type. This method is typically used to remove properties
                from the entity type that were added by convention.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDelete">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; OnDelete (Microsoft.EntityFrameworkCore.DeleteBehavior deleteBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; OnDelete(valuetype Microsoft.EntityFrameworkCore.DeleteBehavior deleteBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OnDelete(Microsoft.EntityFrameworkCore.DeleteBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deleteBehavior" Type="Microsoft.EntityFrameworkCore.DeleteBehavior" />
      </Parameters>
      <Docs>
        <param name="deleteBehavior"> The action to perform. </param>
        <summary>
                Configures how a delete operation is applied to dependent entities in the relationship when the
                principal is deleted or the relationship is severed.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt; OwnsOne&lt;TNewRelatedEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; navigationExpression) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt; OwnsOne&lt;class TNewRelatedEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; navigationExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsOne``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsOne(Of TNewRelatedEntity As Class) (navigationExpression As Expression(Of Func(Of TRelatedEntity, TNewRelatedEntity))) As ReferenceOwnershipBuilder(Of TRelatedEntity, TNewRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the reference navigation property on this entity type that represents
                the relationship (<c>customer =&gt; customer.Address</c>).
            </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                    The target entity key value is always propagated from the entity it belongs to.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the entity type. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnsOne&lt;TNewRelatedEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; OwnsOne&lt;TNewRelatedEntity&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; navigationExpression, Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt; buildAction) where TNewRelatedEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; OwnsOne&lt;class TNewRelatedEntity&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; navigationExpression, class System.Action`1&lt;class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TRelatedEntity, !!TNewRelatedEntity&gt;&gt; buildAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.OwnsOne``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Action{Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OwnsOne(Of TNewRelatedEntity As Class) (navigationExpression As Expression(Of Func(Of TRelatedEntity, TNewRelatedEntity)), buildAction As Action(Of ReferenceOwnershipBuilder(Of TRelatedEntity, TNewRelatedEntity))) As ReferenceOwnershipBuilder(Of TEntity, TRelatedEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewRelatedEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="navigationExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" />
        <Parameter Name="buildAction" Type="System.Action&lt;Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TRelatedEntity,TNewRelatedEntity&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewRelatedEntity"> The entity type that this relationship targets. </typeparam>
        <param name="navigationExpression">
                A lambda expression representing the reference navigation property on this entity type that represents
                the relationship (<c>customer =&gt; customer.Address</c>).
            </param>
        <param name="buildAction"> An action that performs configuration of the relationship. </param>
        <summary>
          <para>
                    Configures a relationship where the target entity is owned by (or part of) this entity.
                    The target entity key value is always propagated from the entity it belongs to.
                </para>
          <para>
                    The target entity type for each ownership relationship is treated as a different entity type
                    even if the navigation is of the same type. Configuration of the target entity type
                    isn't applied to the target entity type of other ownership relationships.
                </para>
          <para>
                    Most operations on an owned entity require accessing it through the owner entity using the corresponding navigation.
                </para>
        </summary>
        <returns> An object that can be used to configure the entity type. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property&lt;TProperty&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; Property&lt;TProperty&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TRelatedEntity,TProperty&gt;&gt; propertyExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!!TProperty&gt; Property&lt;TProperty&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TRelatedEntity, !!TProperty&gt;&gt; propertyExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.Property``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Property(Of TProperty) (propertyExpression As Expression(Of Func(Of TRelatedEntity, TProperty))) As PropertyBuilder(Of TProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProperty" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="propertyExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TRelatedEntity,TProperty&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProperty"> The type of the property to be configured. </typeparam>
        <param name="propertyExpression">
                A lambda expression representing the property to be configured (
                <c>blog =&gt; blog.Url</c>).
            </param>
        <summary>
          <para>
                    Returns an object that can be used to configure a property of the entity type.
                    If no property with the given name exists, then a new property will be added.
                </para>
          <para>
                    When adding a new property, if a property with the same name exists in the entity class
                    then it will be added to the model. If no property exists in the entity class, then
                    a new shadow state property will be added. A shadow state property is one that does not have a
                    corresponding property in the entity class. The current value for the property is stored in
                    the <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker" /> rather than being stored in instances of the entity class.
                </para>
        </summary>
        <returns> An object that can be used to configure the property. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UsePropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt; UsePropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2&lt;!TEntity, !TRelatedEntity&gt; UsePropertyAccessMode(valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder`2.UsePropertyAccessMode(Microsoft.EntityFrameworkCore.PropertyAccessMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.ReferenceOwnershipBuilder&lt;TEntity,TRelatedEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="Microsoft.EntityFrameworkCore.PropertyAccessMode" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode"> The <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> to use for properties of this entity type. </param>
        <summary>
          <para>
                    Sets the <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> to use for all properties of this entity type.
                </para>
          <para>
                    By default, the backing field, if one is found by convention or has been specified, is used when
                    new objects are constructed, typically when entities are queried from the database.
                    Properties are used for all other accesses.  Calling this method witll change that behavior
                    for all properties of this entity type as described in the <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> enum.
                </para>
          <para>
                    Calling this method overrides for all properties of this entity type any access mode that was
                    set on the model.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>